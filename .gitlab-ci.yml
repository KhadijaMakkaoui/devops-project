stages:
  - validate
  - infra_plan
  - infra_apply
  - build
  - package
  - deploy
  - post_deploy
  - cleanup

variables:
  TF_INPUT: "false"
  TF_IN_AUTOMATION: "true"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

  ECR_REGISTRY: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
  REPO_BACKEND: "brief3-backend"
  REPO_FRONTEND: "brief3-frontend"

  IMAGE_TAG: $CI_COMMIT_SHORT_SHA
  LAMBDA_S3_KEY: "lambda/worker/lambda_nodejs.zip"

package_lambda:
  stage: validate
  image: node:20-alpine
  script:
    - apk add --no-cache zip unzip
    - mkdir -p dist
    - cd lambda/worker && zip -r ../../dist/lambda_nodejs.zip index.js
    - unzip -t ../../dist/lambda_nodejs.zip
  artifacts:
    paths:
      - dist/lambda_nodejs.zip
    expire_in: 1h

terraform_validate:
  stage: validate
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  script:
    - cd terraform/dev
    - terraform init -backend=false
    - terraform validate

terraform_plan:
  stage: infra_plan
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  needs:
    - job: terraform_validate
  script:
    - cd terraform/dev
    - terraform init
    - |
      terraform plan -out=tfplan \
        -var="lambda_s3_key=${LAMBDA_S3_KEY}" \
        -var="image_tag=${IMAGE_TAG}" \
        -var="db_password=${TF_VAR_db_password}"
  artifacts:
    paths:
      - terraform/dev/tfplan
    expire_in: 1h
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

terraform_apply_infra:
  stage: infra_apply
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  needs:
    - job: terraform_plan
      artifacts: true
  script:
    - cd terraform/dev
    - terraform init
    - terraform apply -auto-approve tfplan
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

build_backend:
  stage: build
  image: maven:3.8.5-openjdk-17
  script:
    - cd product-service && chmod +x mvnw && ./mvnw clean package -DskipTests
  artifacts:
    paths:
      - product-service/target/*.jar

build_frontend:
  stage: build
  image: node:20-alpine
  script:
    - cd product-service-fe && npm install && npm run build -- --configuration=production
  artifacts:
    paths:
      - product-service-fe/dist/

.docker_setup: &docker_setup
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - apk add --no-cache aws-cli
    - test -n "$AWS_REGION"
    - aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"

package_backend:
  <<: *docker_setup
  stage: package
  needs:
    - job: build_backend
      artifacts: true
  script:
    - cd product-service
    - docker build -t "$ECR_REGISTRY/$REPO_BACKEND:$IMAGE_TAG" .
    - docker push "$ECR_REGISTRY/$REPO_BACKEND:$IMAGE_TAG"
    - docker tag "$ECR_REGISTRY/$REPO_BACKEND:$IMAGE_TAG" "$ECR_REGISTRY/$REPO_BACKEND:latest"
    - docker push "$ECR_REGISTRY/$REPO_BACKEND:latest"

package_frontend:
  <<: *docker_setup
  stage: package
  needs:
    - job: build_frontend
      artifacts: true
  script:
    - cd product-service-fe
    - docker build -t "$ECR_REGISTRY/$REPO_FRONTEND:$IMAGE_TAG" .
    - docker push "$ECR_REGISTRY/$REPO_FRONTEND:$IMAGE_TAG"
    - docker tag "$ECR_REGISTRY/$REPO_FRONTEND:$IMAGE_TAG" "$ECR_REGISTRY/$REPO_FRONTEND:latest"
    - docker push "$ECR_REGISTRY/$REPO_FRONTEND:latest"

upload_lambda_s3:
  stage: deploy
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  needs:
    - job: package_lambda
      artifacts: true
    - job: terraform_apply_infra
  script:
    - apk add --no-cache aws-cli
    - test -n "$AWS_REGION"
    - test -f "${CI_PROJECT_DIR}/dist/lambda_nodejs.zip"
    - cd terraform/dev
    - terraform init
    - export LAMBDA_S3_BUCKET="$(terraform output -raw lambda_artifacts_bucket)"
    - test -n "$LAMBDA_S3_BUCKET"
    - aws s3 cp "${CI_PROJECT_DIR}/dist/lambda_nodejs.zip" "s3://${LAMBDA_S3_BUCKET}/${LAMBDA_S3_KEY}" --region "$AWS_REGION"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

terraform_apply_lambda:
  stage: post_deploy
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  needs:
    - job: upload_lambda_s3
    - job: terraform_apply_infra
  script:
    - cd terraform/dev
    - terraform init
    - terraform apply -auto-approve
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

deploy_ecs:
  stage: post_deploy
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  needs:
    - job: terraform_apply_lambda
    - job: package_backend
    - job: package_frontend
  script:
    - apk add --no-cache aws-cli
    - cd terraform/dev
    - terraform init
    - export ECS_CLUSTER_NAME="$(terraform output -raw ecs_cluster_name)"
    - export ECS_SERVICE_NAME="$(terraform output -raw ecs_service_name)"
    - test -n "$ECS_CLUSTER_NAME"
    - test -n "$ECS_SERVICE_NAME"
    - test -n "$AWS_REGION"
    - aws ecs update-service --cluster "$ECS_CLUSTER_NAME" --service "$ECS_SERVICE_NAME" --force-new-deployment --region "$AWS_REGION"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

terraform_destroy:
  stage: cleanup
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  script:
    - cd terraform/dev
    - terraform init
    - terraform destroy -auto-approve -var="lambda_s3_key=${LAMBDA_S3_KEY}"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: false
